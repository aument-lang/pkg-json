import "./lexer.au" as lexer;

class parser {
    var lexer;
}

def new(string) {
    return new parser {
        lexer: lexer::new(string),
    };
}

def (self: parser) next() {
    return @lexer.lexer::next();
}

def (self: parser) expect_op(string) {
    token = self.next();
    if token.lexer::t_type() != lexer::TOKEN_OP {
        // TODO: error
        print "expected operator\n";
        sys::abort();
    }
    if token.lexer::t_data() != string {
        // TODO: error
        print "expected ", string, "\n";
        sys::abort();
    }
}

def (self: parser) do_parse_value() {
    token = self.next();
    type = token.lexer::t_type();
    if (
        type == lexer::TOKEN_STRING ||
        type == lexer::TOKEN_NUMBER
    ) {
        return token.lexer::t_data();
    } else if type == lexer::TOKEN_OP {
        source = token.lexer::t_data();
        if source == '[' {
            return self.do_parse_array();
        } else if source == '{' {
            return self.do_parse_object();
        }
    }
    // TODO: error
    sys::abort();
}

def (self: parser) do_parse_object() {
    token = self.next();
    if token.lexer::t_type() == lexer::TOKEN_STRING {
        key = token;
        self.expect_op(":");
        value = self.do_parse_value();
    } else if (
        token.lexer::t_type() != lexer::TOKEN_OP ||
        token.lexer::t_data() != '}'
    ) {
        // TODO: error
        sys::abort();
    }
}

def (self: parser) do_parse_array() {
    array = [];
    token = self.next();
    if (
        token.lexer::t_type() == lexer::TOKEN_OP &&
        token.lexer::t_data() == ']'
    ) {
        return array;
    } else {
        array.array::push(self.do_parse_value());
    }
    while token = self.next() {
        if token.lexer::t_type() == lexer::TOKEN_OP {
            op = token.lexer::t_data();
            if op == ']' {
                return array;
            } else if op == ',' {
                array.array::push(self.do_parse_value());
            } else {
                // TODO: error
                sys::abort();
            }
        } else {
            // TODO: error
            sys::abort();
        }
    }
}

// ** Public methods **
export def parse(source) {
    parser = new(source);
    parser.expect_op("{");
    return parser.do_parse_object();
}
